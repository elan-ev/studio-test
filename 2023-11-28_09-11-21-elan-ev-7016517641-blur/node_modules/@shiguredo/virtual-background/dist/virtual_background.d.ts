/// <reference types="dom-mediacapture-transform" />
/**
 * {@link VirtualBackgroundProcessor.startProcessing} メソッドに指定可能なオプション
 */
interface VirtualBackgroundProcessorOptions {
    /**
     * 仮想背景に使用する画像
     *
     * 省略された場合には、元々の背景が使用されます
     */
    backgroundImage?: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap | OffscreenCanvas;
    /**
     * 背景ぼかし効果の半径（pixel）
     *
     * 値が大きいほど、ぼかしが強くなります。
     * デフォルトではぼかしは無効で、これは値として0を指定した場合の挙動と等しいです。
     */
    blurRadius?: number;
    /**
     * セグメンテーションに使用するモデル
     *
     * デフォルトでは"selfie-landscape"が使用されます。
     * それぞれのモデルの詳細については
     * [MediaPipe Selfie Segmentation](https://google.github.io/mediapipe/solutions/selfie_segmentation.html)
     * を参照してください。
     */
    segmentationModel?: "selfie-landscape" | "selfie-general";
    /**
     * 背景画像のどの領域を使用するかを決定する関数
     *
     * 背景画像と処理対象映像のアスペクト比が異なる場合の扱いを決定するために使用されます
     *
     * デフォルトでは、背景画像のアスペクト比を維持したまま中央部分を切り抜く {@link cropBackgroundImageCenter} が使われます
     */
    backgroundImageRegion?: (videoFrame: ImageSize, backgroundImage: ImageSize) => ImageRegion;
}
/**
 * 画像の幅と高さ
 */
interface ImageSize {
    width: number;
    height: number;
}
/**
 * 画像の領域（始点とサイズ）
 */
interface ImageRegion {
    x: number;
    y: number;
    width: number;
    height: number;
}
/**
 * 背景画像と処理対象映像のアスペクトが異なる場合に、背景画像の中央部分を切り抜いた領域を返します
 *
 * これは {@link VirtualBackgroundProcessorOptions.backgroundImageRegion} オプションのデフォルトの挙動です
 */
declare function cropBackgroundImageCenter(videoFrame: ImageSize, backgroundImage: ImageSize): ImageRegion;
/**
 * 常に背景画像の全領域を返します
 *
 * これは {@link VirtualBackgroundProcessorOptions.backgroundImageRegion} オプションに指定可能な関数で、
 * 背景画像と処理対象映像のアスペクト比が異なる場合には、背景画像が映像に合わせて引き伸ばされます
 */
declare function fillBackgroundImage(_videoFrame: ImageSize, backgroundImage: ImageSize): ImageRegion;
/**
 * 映像トラックに仮想背景処理を適用するためのプロセッサ
 */
declare class VirtualBackgroundProcessor {
    private trackProcessor;
    private segmentation;
    /**
     * {@link VirtualBackgroundProcessor} インスタンスを生成します
     *
     * @param assetsPath wasm 等のファイルの配置先ディレクトリパスないしURL
     */
    constructor(assetsPath: string);
    /**
     * 実行環境が必要な機能をサポートしているかどうかを判定します
     *
     * 以下のいずれかが利用可能である必要があります:
     * - MediaStreamTrack Insertable Streams (aka. Breakout Box)
     * - HTMLVideoElement.requestVideoFrameCallback
     *
     * @returns サポートされているかどうか
     */
    static isSupported(): boolean;
    /**
     * 仮想背景処理の適用を開始します
     *
     * @param track 処理適用対象となる映像トラック
     * @param options 各種オプション
     *
     * @returns 処理適用後の映像トラック
     *
     * @throws
     * 既にあるトラックを処理中の場合には、エラーが送出されます
     *
     * 処理中かどうかは {@link VirtualBackgroundProcessor.isProcessing} で判定可能です
     */
    startProcessing(track: MediaStreamVideoTrack, options?: VirtualBackgroundProcessorOptions): Promise<MediaStreamVideoTrack>;
    /**
     * 仮想背景処理の適用を停止します
     *
     * コンストラクタに渡された映像トラックは閉じないので、
     * 必要であれば、別途呼び出し側で対処する必要があります
     */
    stopProcessing(): void;
    /**
     * 仮想背景処理が実行中かどうかを判定します
     *
     * @returns 実行中であれば `true` 、そうでなければ `false`
     */
    isProcessing(): boolean;
    /**
     * 処理適用前の映像トラックを返します
     *
     * これは {@link VirtualBackgroundProcessor.startProcessing} に渡したトラックと等しいです
     *
     * {@link VirtualBackgroundProcessor.startProcessing} 呼び出し前、あるいは、
     * {@link VirtualBackgroundProcessor.stopProcessing} 呼び出し後には `undefined` が返されます
     *
     * @returns 処理適用中の場合は映像トラック、それ以外なら `undefined`
     */
    getOriginalTrack(): MediaStreamVideoTrack | undefined;
    /**
     * 処理適用後の映像トラックを返します
     *
     * これは {@link VirtualBackgroundProcessor.startProcessing} が返したトラックと等しいです
     *
     * {@link VirtualBackgroundProcessor.startProcessing} 呼び出し前、あるいは、
     * {@link VirtualBackgroundProcessor.stopProcessing} 呼び出し後には `undefined` が返されます
     *
     * @returns 処理適用中の場合は映像トラック、それ以外なら `undefined`
     */
    getProcessedTrack(): MediaStreamVideoTrack | undefined;
    private updateOffscreenCanvas;
}
export { VirtualBackgroundProcessorOptions, VirtualBackgroundProcessor, ImageRegion, ImageSize, cropBackgroundImageCenter, fillBackgroundImage, };
